#!/usr/bin/env python3
# Smoke-test for the RMAP HTTP server: completes the handshake and downloads the PDF once.

from __future__ import annotations
import os
import sys
import json
import base64
import requests
from pathlib import Path
from urllib.parse import urljoin
from pgpy import PGPKey, PGPMessage

# ---- Import IdentityManager from installed rmap (or local src fallback) ----
try:
    from rmap.identity_manager import IdentityManager
except ModuleNotFoundError:
    sys.path.insert(0, str(Path(__file__).resolve().parent / "server" / "src"))
    from rmap.identity_manager import IdentityManager  # type: ignore

# ---- Config (env-overridable) ----
BASE = os.environ.get("BASE", "http://localhost:5000")
if not BASE.startswith(("http://", "https://")):
    BASE = "http://" + BASE  # make requests happy if scheme omitted

IDENTITY = os.environ.get("IDENTITY", "Alice")
ALICE_PASSPHRASE = os.environ.get("ALICE_PASSPHRASE")  # only if Alice key is protected

# point to the /server directory (one level above /server/test)
repo = Path(__file__).resolve().parents[1]  # .../server
keys_dir = repo / "keys"
clients_dir = keys_dir / "clients"
server_pub = keys_dir / "server_public.asc"
server_priv = keys_dir / "server_private.asc"
alice_priv = clients_dir / f"{IDENTITY}_private.asc"

# ---- Sanity checks ----
for p in [clients_dir, server_pub, server_priv, alice_priv]:
    if not p.exists():
        print(f"Missing: {p}")
        sys.exit(2)

# ---- Build helper (uses server pub/priv + clients dir) ----
im = IdentityManager(
    client_keys_dir=clients_dir,
    server_public_key_path=server_pub,
    server_private_key_path=server_priv,
    server_private_key_passphrase=os.environ.get("RMAP_SERVER_PRIV_PASSPHRASE"),
)

# ---------------- Message 1 ----------------
nonce_client = 54891657
msg1_plain = {"nonceClient": nonce_client, "identity": IDENTITY}
msg1 = {"payload": im.encrypt_for_server(msg1_plain)}

r1 = requests.post(urljoin(BASE, "/rmap-initiate"), json=msg1, timeout=10)
print("rmap-initiate:", r1.status_code, r1.text)
r1.raise_for_status()

# Decrypt Response 1 with Alice's private key (client side) — handle binary payloads
payload_b64 = r1.json()["payload"]
payload_bytes = base64.b64decode(payload_b64)
pgp_msg = PGPMessage.from_blob(payload_bytes)

alice_key, _ = PGPKey.from_file(str(alice_priv))
if alice_key.is_protected and ALICE_PASSPHRASE:
    alice_key.unlock(ALICE_PASSPHRASE)

resp1_plain = json.loads(alice_key.decrypt(pgp_msg).message)
print("Decrypted Response1:", resp1_plain)
nonce_server = int(resp1_plain["nonceServer"])

# ---------------- Message 2 ----------------
msg2 = {"payload": im.encrypt_for_server({"nonceServer": nonce_server})}
r2 = requests.post(urljoin(BASE, "/rmap-get-link"), json=msg2, timeout=10)
print("rmap-get-link:", r2.status_code, r2.text)
r2.raise_for_status()

data = r2.json()
if "link" not in data:
    print("Unexpected response from /rmap-get-link:", data)
    sys.exit(1)

link = data["link"]
print("One-time download link:", link, "\nExpires at:", data.get("expires"))

# ---- Download the PDF once (token is single-use and time-limited) ----
out_path = repo / "got.pdf"
r3 = requests.get(link, timeout=15)
ct = (r3.headers.get("content-type") or "").lower()
if r3.status_code != 200 or not ct.startswith("application/pdf"):
    print("Download failed:", r3.status_code, r3.text[:200])
    sys.exit(1)

out_path.write_bytes(r3.content)
print(f"Downloaded PDF → {out_path} ({len(r3.content)} bytes)")


---

#!/usr/bin/env python3
"""
Tiny RMAP client for the SOFTSEC project.

Usage example:
    export CLIENT_PASSPHRASE='your-private-key-passphrase'   # or omit to be prompted
    python server/get_rmap.py 127.0.0.1 --port 5000 \
      --identity Group_05 \
      --server-pub server/keys/server_public.asc \
      --outdir rmap_pdf
"""

import os
import sys
import json
import base64
import argparse
import time
from pathlib import Path
from getpass import getpass

import requests
from pgpy import PGPKey, PGPMessage

# Import rmap from installed wheel; fall back to local src for dev
try:
    from rmap.identity_manager import IdentityManager
except ModuleNotFoundError:
    sys.path.insert(0, str(Path(__file__).resolve().parent / "server" / "src"))
    from rmap.identity_manager import IdentityManager  # type: ignore

# --- Paths -------------------------------------------------------------------

ROOT_DIR = Path(__file__).resolve().parent
if (ROOT_DIR / "keys" / "clients").is_dir():
    # running from tatou/server/
    ROOT = ROOT_DIR.parent
    KEYS = ROOT_DIR / "keys"
else:
    # running from project root tatou/
    ROOT = ROOT_DIR
    KEYS = ROOT / "server" / "keys"

CLIENTS = KEYS / "clients"


# --- Helpers -----------------------------------------------------------------

def load_priv(identity: str) -> tuple[PGPKey, str | None]:
    """Load the private key for the given identity and (optionally) get the passphrase."""
    priv = CLIENTS / f"{identity}_private.asc"
    if not priv.exists():
        print(f"[!] Missing private key: {priv}")
        sys.exit(2)

    key, _ = PGPKey.from_file(str(priv))
    pw = None
    if key.is_protected:
        pw = os.environ.get("CLIENT_PASSPHRASE") or getpass(f"Passphrase for {priv.name}: ")
        # Do NOT unlock here permanently; use context manager at decrypt time
    return key, pw


def build_im(server_pub: Path) -> IdentityManager:
    """Build an IdentityManager using our clients dir and the TARGET server's public key."""
    server_priv = KEYS / "server_private.asc"  # required by ctor; not used by this client
    if not server_pub.exists():
        print(f"[!] Server public key not found: {server_pub}")
        sys.exit(2)
    return IdentityManager(
        client_keys_dir=CLIENTS,
        server_public_key_path=server_pub,
        server_private_key_path=server_priv,
        server_private_key_passphrase=os.environ.get("RMAP_SERVER_PRIV_PASSPHRASE"),
    )


def _pgpmessage_from_b64(b64_payload: str) -> PGPMessage:
    """Accepts base64 of either BINARY or ASCII-armored PGP; returns PGPMessage."""
    raw = base64.b64decode(b64_payload)
    try:
        return PGPMessage.from_blob(raw)               # binary payload
    except Exception:
        return PGPMessage.from_blob(raw.decode("utf-8"))  # ASCII-armored


# --- Main --------------------------------------------------------------------

def main():
    ap = argparse.ArgumentParser(description="Tiny RMAP client (strict endpoints).")
    ap.add_argument("server", help="server IP or host, e.g. 10.11.202.18")
    ap.add_argument("--port", type=int, default=5000)
    ap.add_argument("--identity", default="Group_05")
    ap.add_argument("--server-pub", required=True, help="path to TARGET server public key (.asc)")
    ap.add_argument("--outdir", default=str((ROOT / "rmap_pdf")))
    args = ap.parse_args()

    # Keys + crypto manager
    priv, priv_pw = load_priv(args.identity)
    im = build_im(Path(args.server_pub))

    base = f"http://{args.server}:{args.port}"
    outdir = Path(args.outdir)
    outdir.mkdir(parents=True, exist_ok=True)

    # ---------------------------
    # Client -> Server : Message 1
    # ---------------------------
    nonce_client = int(time.time() * 1_000_000) & 0xFFFFFFFF
    msg1_plain = {"nonceClient": nonce_client, "identity": args.identity}
    payload1 = {"payload": im.encrypt_for_server(msg1_plain)}

    try:
        r1 = requests.post(f"{base}/rmap-initiate", json=payload1, timeout=10)
    except Exception as e:
        print("[!] HTTP error calling /rmap-initiate:", e)
        sys.exit(1)

    print("rmap-initiate:", r1.status_code)
    if r1.status_code != 200 or not r1.headers.get("content-type", "").lower().startswith("application/json"):
        print("Body:", r1.text[:400])
        sys.exit(1)

    try:
        pgp_msg = _pgpmessage_from_b64(r1.json()["payload"])
        # Proper unlock scope for PGPy
        if priv.is_protected:
            with priv.unlock(priv_pw):
                resp1_plain = json.loads(priv.decrypt(pgp_msg).message)
        else:
            resp1_plain = json.loads(priv.decrypt(pgp_msg).message)
        nonce_server = int(resp1_plain["nonceServer"])
    except Exception as e:
        print("[!] Failed to decrypt/parse Response 1:", e)
        print("Payload head:", r1.json().get("payload", "")[:60])
        sys.exit(1)

    # ---------------------------
    # Client -> Server : Message 2
    # ---------------------------
    payload2 = {"payload": im.encrypt_for_server({"nonceServer": nonce_server})}

    try:
        r2 = requests.post(f"{base}/rmap-get-link", json=payload2, timeout=10)
    except Exception as e:
        print("[!] HTTP error calling /rmap-get-link:", e)
        sys.exit(1)

    print("rmap-get-link:", r2.status_code)
    if r2.status_code != 200 or not r2.headers.get("content-type", "").lower().startswith("application/json"):
        print("Body:", r2.text[:400])
        sys.exit(1)

    data = r2.json()
    if "link" not in data:
        print("No 'link' in response:", data)
        sys.exit(1)

    # ---------------------------
    # Download the PDF
    # ---------------------------
    try:
        r3 = requests.get(data["link"], timeout=15)
    except Exception as e:
        print("[!] HTTP error downloading PDF:", e)
        sys.exit(1)

    if r3.status_code != 200 or "application/pdf" not in r3.headers.get("content-type", "").lower():
        print("Download failed:", r3.status_code, r3.text[:400])
        sys.exit(1)

    dest = outdir / f"{args.server}__{args.identity}.pdf"
    dest.write_bytes(r3.content)
    print(f"[✓] Saved → {dest} ({len(r3.content)} bytes)")


if __name__ == "__main__":
    main()

------


    # ====================== RMAP: setup + endpoints ======================

    app.config.setdefault("RMAP_PDF_PATH", os.environ.get("RMAP_PDF_PATH", "/app/storage/handout.pdf"))
    app.config.setdefault("RMAP_LINK_TTL", int(os.environ.get("RMAP_LINK_TTL", "600")))
    app.config.setdefault("RMAP_TOKENS", {})  # token -> expiry (epoch seconds)

    # Key paths
    SERVER_DIR = Path(__file__).resolve().parents[1]   # /app/server
    DEFAULT_KEYS_DIR = SERVER_DIR / "keys"
    rmap_keys_dir = Path(os.environ.get("RMAP_KEYS_DIR", str(DEFAULT_KEYS_DIR))).resolve()
    clients_dir = rmap_keys_dir / "clients"
    server_pub  = rmap_keys_dir / "server_public.asc"
    server_priv = rmap_keys_dir / "server_private.asc"
    server_priv_pass = os.environ.get("RMAP_SERVER_PRIV_PASSPHRASE")

    # Initialize RMAP
    missing = [p for p in (clients_dir, server_pub, server_priv) if not p.exists()]
    if missing:
        app.logger.error("RMAP key path(s) missing: %s", ", ".join(map(str, missing)))
        app.config["RMAP"] = None
    else:
        try:
            im = IdentityManager(
                client_keys_dir=clients_dir,
                server_public_key_path=server_pub,
                server_private_key_path=server_priv,
                server_private_key_passphrase=server_priv_pass,
            )
            app.config["RMAP"] = RMAP(im)
            app.logger.info("RMAP initialized (clients dir: %s)", clients_dir)
        except Exception as e:
            app.logger.exception("Failed to initialize RMAP: %s", e)
            app.config["RMAP"] = None

    # Helper: mint a one-time, time-limited download link from RMAP result
    def _rmap_make_link(result_hex: str) -> dict:
        token = result_hex.lower()
        expires = int(time.time()) + app.config["RMAP_LINK_TTL"]
        app.config["RMAP_TOKENS"][token] = expires
        log_event("rmap-link-minted", user="rmap", status="OK")
        return {
            "link": url_for("rmap_download", token=token, _external=True),
            "expires": expires,
        }

    # Message 1 -> Response 1
    @app.post("/rmap-initiate")
    @app.post("/api/rmap-initiate")
    def rmap_initiate():
        rmap = app.config.get("RMAP")
        if rmap is None:
            log_event("rmap-initiate-not-initialized", user="rmap", status="FAIL")
            return jsonify({"error": "RMAP not initialized"}), 503
        body = request.get_json(silent=True) or {}
        if "payload" not in body:
            log_event("rmap-initiate-missing-payload", user="rmap", status="FAIL")
            return jsonify({"error": "payload is required"}), 400
        try:
            out = rmap.handle_message1(body)  # {"payload": "..."} or {"error": "..."}
            if "payload" in out:
                log_event("rmap-initiate-success", user="rmap", status="OK")
                return jsonify(out), 200
            else:
                log_event("rmap-initiate-failed", user="rmap", status="FAIL")
                return jsonify(out), 400
        except Exception as e:
            app.logger.exception("rmap-initiate failed: %s", e)
            log_event("rmap-initiate-exception", user="rmap", status="ERROR")
            return jsonify({"error": "server error"}), 500

    # Message 2 -> one-time link
    @app.post("/rmap-get-link")
    @app.post("/api/rmap-get-link")
    def rmap_get_link():
        rmap = app.config.get("RMAP")
        if rmap is None:
            log_event("rmap-get-link-not-initialized", user="rmap", status="FAIL")
            return jsonify({"error": "RMAP not initialized"}), 503
        body = request.get_json(silent=True) or {}
        if "payload" not in body:
            log_event("rmap-get-link-missing-payload", user="rmap", status="FAIL")
            return jsonify({"error": "payload is required"}), 400
        try:
            out = rmap.handle_message2(body)  # {"result": "<32-hex>"} or {"error": "..."}
            if "result" not in out:
                log_event("rmap-get-link-failed", user="rmap", status="FAIL")
                return jsonify(out), 400
            log_event("rmap-get-link-success", user="rmap", status="OK")
            return jsonify(_rmap_make_link(out["result"])), 200
        except Exception as e:
            app.logger.exception("rmap-get-link failed: %s", e)
            log_event("rmap-get-link-exception", user="rmap", status="ERROR")
            return jsonify({"error": "server error"}), 500

    # One-time download endpoint
    @app.get("/rmap-download/<token>")
    def rmap_download(token: str):
        tokens = app.config.get("RMAP_TOKENS", {})
        expires = tokens.pop(token, None)  # one-time use
        if not expires:
            log_event("rmap-download-invalid-token", user="rmap", status="FAIL")
            abort(404)

        if time.time() > expires:
            log_event("rmap-download-expired-token", user="rmap", status="FAIL")
            abort(404)

        pdf_path = Path(app.config["RMAP_PDF_PATH"])
        if not pdf_path.exists():
            app.logger.error("RMAP_PDF_PATH missing: %s", pdf_path)
            log_event("rmap-download-missing-pdf", user="rmap", status="ERROR")
            abort(500)
        log_event("rmap-download-success", user="rmap", status="OK")
        return send_file(
            str(pdf_path),
            mimetype="application/pdf",
            as_attachment=True,
            download_name="Group_5.pdf",
            max_age=0,
            conditional=False,
            etag=False,
            last_modified=None,
        )

    # ====================== end RMAP section ======================





# test api below 

# server/test/test_api.py

import io
import uuid
import pytest

from server import app


@pytest.fixture
def client():
    app.config["TESTING"] = True
    return app.test_client()


@pytest.fixture
def user_credentials():
    """
    Generate a unique user each test run to avoid UNIQUE(email/login) collisions
    in the DB.
    """
    suffix = uuid.uuid4().hex[:8]
    email = f"test_{suffix}@example.com"
    login = f"user_{suffix}"
    password = "Secr3tP@ss!"
    return {"email": email, "login": login, "password": password}


@pytest.fixture
def auth_header(client, user_credentials):
    """
    Create a user + log in, returns {"Authorization": "Bearer <token>"} header.
    """
    # create-user
    resp = client.post("/api/create-user", json={
        "email": user_credentials["email"],
        "login": user_credentials["login"],
        "password": user_credentials["password"],
    })
    assert resp.status_code in (201, 409)  # 409 if you re-run with same email

    # login
    resp = client.post("/api/login", json={
        "email": user_credentials["email"],
        "password": user_credentials["password"],
    })
    assert resp.status_code == 200
    data = resp.get_json()
    assert "token" in data

    token = data["token"]
    return {"Authorization": f"Bearer {token}"}


@pytest.fixture
def uploaded_document_id(client, auth_header):
    """
    Uploads a tiny PDF-like file and returns its document id.
    """
    fake_pdf = b"%PDF-1.4\n%test\n"
    data = {
        "file": (io.BytesIO(fake_pdf), "test.pdf"),
        "name": "test.pdf",
    }
    resp = client.post(
        "/api/upload-document",
        data=data,
        headers=auth_header,
        content_type="multipart/form-data",
    )
    assert resp.status_code == 201
    body = resp.get_json()
    assert "id" in body
    return body["id"]


# ---------------------------------------------------------------------
# Basic health / public endpoints
# ---------------------------------------------------------------------

def test_healthz_route(client):
    # This is the one you already had
    resp = client.get("/healthz")
    assert resp.status_code == 200
    assert resp.is_json
    assert "message" in resp.get_json()


def test_get_watermarking_methods(client):
    resp = client.get("/api/get-watermarking-methods")
    assert resp.status_code == 200
    assert resp.is_json
    data = resp.get_json()
    assert "methods" in data
    assert "count" in data
    # It’s ok if count == 0, but usually you’ll have some methods registered.


# ---------------------------------------------------------------------
# Auth / user lifecycle
# ---------------------------------------------------------------------

def test_create_user_and_login_flow(client, user_credentials):
    # create-user
    resp = client.post("/api/create-user", json={
        "email": user_credentials["email"],
        "login": user_credentials["login"],
        "password": user_credentials["password"],
    })
    assert resp.status_code in (201, 409)
    if resp.status_code == 201:
        body = resp.get_json()
        assert "id" in body
        assert body["email"] == user_credentials["email"]
        assert body["login"] == user_credentials["login"]

    # login
    resp = client.post("/api/login", json={
        "email": user_credentials["email"],
        "password": user_credentials["password"],
    })
    assert resp.status_code == 200
    body = resp.get_json()
    assert body["token_type"] == "bearer"
    assert isinstance(body["expires_in"], int)


def test_login_missing_fields(client):
    # No password
    resp = client.post("/api/login", json={"email": "x@example.com"})
    assert resp.status_code == 400
    assert resp.is_json


# ---------------------------------------------------------------------
# Documents: upload / list / get / delete
# ---------------------------------------------------------------------

def test_upload_and_list_documents(client, auth_header):
    fake_pdf = b"%PDF-1.4\nHello"
    data = {
        "file": (io.BytesIO(fake_pdf), "hello.pdf"),
        "name": "hello.pdf",
    }

    # upload-document
    resp = client.post(
        "/api/upload-document",
        data=data,
        headers=auth_header,
        content_type="multipart/form-data",
    )
    assert resp.status_code == 201
    created = resp.get_json()
    assert created["name"] == "hello.pdf"
    doc_id = created["id"]

    # list-documents
    resp = client.get("/api/list-documents", headers=auth_header)
    assert resp.status_code == 200
    docs = resp.get_json()["documents"]
    assert any(d["id"] == doc_id for d in docs)


def test_get_document_by_id(client, auth_header, uploaded_document_id):
    # GET /api/get-document/<id>
    resp = client.get(f"/api/get-document/{uploaded_document_id}",
                      headers=auth_header)
    assert resp.status_code == 200
    assert resp.headers["Content-Type"].startswith("application/pdf")


def test_delete_document_flow(client, auth_header, uploaded_document_id):
    # DELETE /api/delete-document/<id>
    resp = client.delete(f"/api/delete-document/{uploaded_document_id}",
                         headers=auth_header)
    assert resp.status_code == 200
    body = resp.get_json()
    assert body["deleted"] is True

    # Subsequent get should 404
    resp = client.get(f"/api/get-document/{uploaded_document_id}",
                      headers=auth_header)
    assert resp.status_code in (404, 410)


# ---------------------------------------------------------------------
# Versions & watermarking
# ---------------------------------------------------------------------

def test_list_versions_empty(client, auth_header, uploaded_document_id):
    # No versions created yet, should return empty list
    resp = client.get(f"/api/list-versions/{uploaded_document_id}",
                      headers=auth_header)
    assert resp.status_code == 200
    body = resp.get_json()
    assert "versions" in body
    # It’s fine if zero – this just exercises the route.
    assert isinstance(body["versions"], list)


def test_list_all_versions(client, auth_header):
    resp = client.get("/api/list-all-versions", headers=auth_header)
    assert resp.status_code == 200
    body = resp.get_json()
    assert "versions" in body
    assert isinstance(body["versions"], list)

    


# NOTE: Fully testing create-watermark / read-watermark “happy path” would
# require knowing exactly how your watermarking methods behave.
# The tests above at least hit the listing endpoints and your separate
# watermarking unit tests cover the actual algorithms.


# ---------------------------------------------------------------------
# RMAP endpoints – just basic coverage
# ---------------------------------------------------------------------

def test_rmap_initiate_missing_payload(client):
    resp = client.post("/api/rmap-initiate", json={})
    # In dev env RMAP may not be initialized, so 400 or 503 is OK
    assert resp.status_code in (400, 503)
    assert resp.is_json


def test_rmap_get_link_missing_payload(client):
    resp = client.post("/api/rmap-get-link", json={})
    assert resp.status_code in (400, 503)
    assert resp.is_json




    def _pick_method_name() -> str:
    # Reuse whatever is registered, skip the unsafe one
    for name in WMUtils.METHODS.keys():
        if name != "UnsafeBashBridgeAppendEOF":
            return name
    pytest.skip("No suitable watermarking method registered")


def test_create_and_read_watermark_happy_path(
    client, auth_header, uploaded_document_id
):
    method_name = _pick_method_name()
    secret = "api-secret"
    key = "api-key"

    # 1) create-watermark
    resp = client.post(
        f"/api/create-watermark/{uploaded_document_id}",
        json={
            "method": method_name,
            "position": None,
            "key": key,
            "secret": secret,
            "intended_for": "UnitTest",
        },
        headers=auth_header,
    )
    assert resp.status_code in (200, 201)
    data = resp.get_json()
    assert data["documentid"] == uploaded_document_id

    # 2) read-watermark
    resp = client.post(
        f"/api/read-watermark/{uploaded_document_id}",
        json={
            "method": method_name,
            "position": None,
            "key": key,
        },
        headers=auth_header,
    )
    assert resp.status_code == 200
    body = resp.get_json()
    assert body["secret"] == secret